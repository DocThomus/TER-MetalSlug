<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Metal Slug: sf::Texture Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Metal Slug
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Un clone de Metal Slug</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsf_1_1_texture.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">sf::Texture Class Reference<div class="ingroups"><a class="el" href="group__graphics.html">Graphics module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="sf::Texture" --><!-- doxytag: inherits="sf::GlResource" -->
<p><a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">Image</a> living on the graphics card that can be used for drawing.  
 <a href="classsf_1_1_texture.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_texture_8hpp_source.html">Texture.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::Texture:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsf_1_1_texture.png" usemap="#sf::Texture_map" alt=""/>
  <map id="sf::Texture_map" name="sf::Texture_map">
<area href="classsf_1_1_gl_resource.html" title="Base class for classes that require an OpenGL context." alt="sf::GlResource" shape="rect" coords="0,0,94,24"/>
</map>
 </div></div>

<p><a href="classsf_1_1_texture-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#aa6fd3bbe3c334b3c4428edfb2765a82e">CoordinateType</a> { <a class="el" href="classsf_1_1_texture.html#aa6fd3bbe3c334b3c4428edfb2765a82ea69d6228950882e4d68be4ba4dbe7df73">Normalized</a>, 
<a class="el" href="classsf_1_1_texture.html#aa6fd3bbe3c334b3c4428edfb2765a82ea6372f9c3a10203a7a69d8d5da59d82ff">Pixels</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of texture coordinates that can be used for rendering.  <a href="classsf_1_1_texture.html#aa6fd3bbe3c334b3c4428edfb2765a82e">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a3e04674853b8533bf981db3173e3a4a7">Texture</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a3e04674853b8533bf981db3173e3a4a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a524855cbf89de3b74be84d385fd229de">Texture</a> (const <a class="el" href="classsf_1_1_texture.html">Texture</a> &amp;copy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a524855cbf89de3b74be84d385fd229de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c5354ad40eb1c5aeeeb21f57ccd7e6c"></a><!-- doxytag: member="sf::Texture::~Texture" ref="a9c5354ad40eb1c5aeeeb21f57ccd7e6c" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a9c5354ad40eb1c5aeeeb21f57ccd7e6c">~Texture</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a89b4c7d204acf1033c3a1b6e0a3ad0a3">create</a> (unsigned int width, unsigned int height)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the texture.  <a href="#a89b4c7d204acf1033c3a1b6e0a3ad0a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a8e1b56eabfe33e2e0e1cb03712c7fcc7">loadFromFile</a> (const std::string &amp;filename, const <a class="el" href="classsf_1_1_rect.html">IntRect</a> &amp;area=<a class="el" href="classsf_1_1_rect.html">IntRect</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the texture from a file on disk.  <a href="#a8e1b56eabfe33e2e0e1cb03712c7fcc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a2c4adb19dd4cbee0a588eeb85e52a249">loadFromMemory</a> (const void *data, std::size_t size, const <a class="el" href="classsf_1_1_rect.html">IntRect</a> &amp;area=<a class="el" href="classsf_1_1_rect.html">IntRect</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the texture from a file in memory.  <a href="#a2c4adb19dd4cbee0a588eeb85e52a249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a6803a13465a7113a8964d1081841886d">loadFromStream</a> (<a class="el" href="classsf_1_1_input_stream.html">sf::InputStream</a> &amp;stream, const <a class="el" href="classsf_1_1_rect.html">IntRect</a> &amp;area=<a class="el" href="classsf_1_1_rect.html">IntRect</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the texture from a custom stream.  <a href="#a6803a13465a7113a8964d1081841886d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#abec4567ad9856a3596dc74803f26fba2">loadFromImage</a> (const <a class="el" href="classsf_1_1_image.html">Image</a> &amp;image, const <a class="el" href="classsf_1_1_rect.html">IntRect</a> &amp;area=<a class="el" href="classsf_1_1_rect.html">IntRect</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the texture from an image.  <a href="#abec4567ad9856a3596dc74803f26fba2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1_vector2.html">Vector2u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a0f370acd8f41c8b97a6959389c521c2c">getSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the texture.  <a href="#a0f370acd8f41c8b97a6959389c521c2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1_image.html">Image</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#aefc19bcd95565dd2348fd4cec0facddc">copyToImage</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the texture pixels to an image.  <a href="#aefc19bcd95565dd2348fd4cec0facddc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#ae4eab5c6781316840b0c50ad08370963">update</a> (const Uint8 *pixels)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the whole texture from an array of pixels.  <a href="#ae4eab5c6781316840b0c50ad08370963"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a1352d8e16c2aeb4df586ed65dd2c36b9">update</a> (const Uint8 *pixels, unsigned int width, unsigned int height, unsigned int x, unsigned int y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a part of the texture from an array of pixels.  <a href="#a1352d8e16c2aeb4df586ed65dd2c36b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a037cdf171af0fb392d07626a44a4ea17">update</a> (const <a class="el" href="classsf_1_1_image.html">Image</a> &amp;image)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the texture from an image.  <a href="#a037cdf171af0fb392d07626a44a4ea17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a87f916490b757fe900798eedf3abf3ba">update</a> (const <a class="el" href="classsf_1_1_image.html">Image</a> &amp;image, unsigned int x, unsigned int y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a part of the texture from an image.  <a href="#a87f916490b757fe900798eedf3abf3ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#ad3cceef238f7d5d2108a98dd38c17fc5">update</a> (const <a class="el" href="classsf_1_1_window.html">Window</a> &amp;window)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the texture from the contents of a window.  <a href="#ad3cceef238f7d5d2108a98dd38c17fc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a154f246eb8059b602076009ab1cfd175">update</a> (const <a class="el" href="classsf_1_1_window.html">Window</a> &amp;window, unsigned int x, unsigned int y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a part of the texture from the contents of a window.  <a href="#a154f246eb8059b602076009ab1cfd175"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a0c3bd6825b9a99714f10d44179d74324">setSmooth</a> (bool smooth)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the smooth filter.  <a href="#a0c3bd6825b9a99714f10d44179d74324"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a1d6643d3c76f2be29dc401dc22749e16">isSmooth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the smooth filter is enabled or not.  <a href="#a1d6643d3c76f2be29dc401dc22749e16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#aaa87d1eff053b9d4d34a24c784a28658">setRepeated</a> (bool repeated)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable repeating.  <a href="#aaa87d1eff053b9d4d34a24c784a28658"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a007a19b48952b7854120bf423c102150">isRepeated</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the texture is repeated or not.  <a href="#a007a19b48952b7854120bf423c102150"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1_texture.html">Texture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a80a089b6b19bb09b83012d5f0e6af9ba">operator=</a> (const <a class="el" href="classsf_1_1_texture.html">Texture</a> &amp;right)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of assignment operator.  <a href="#a80a089b6b19bb09b83012d5f0e6af9ba"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#ae9a4274e7b95ebf7244d09c7445833b0">bind</a> (const <a class="el" href="classsf_1_1_texture.html">Texture</a> *texture, <a class="el" href="classsf_1_1_texture.html#aa6fd3bbe3c334b3c4428edfb2765a82e">CoordinateType</a> coordinateType=<a class="el" href="classsf_1_1_texture.html#aa6fd3bbe3c334b3c4428edfb2765a82ea69d6228950882e4d68be4ba4dbe7df73">Normalized</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a texture for rendering.  <a href="#ae9a4274e7b95ebf7244d09c7445833b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_texture.html#a0bf905d487b104b758549c2e9e20a3fb">getMaximumSize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum texture size allowed.  <a href="#a0bf905d487b104b758549c2e9e20a3fb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2548fc9744f5e43e0276d5627ca178de"></a><!-- doxytag: member="sf::Texture::RenderTexture" ref="a2548fc9744f5e43e0276d5627ca178de" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>RenderTexture</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5afc6f82b7b587ed5ada4d227ce32aa"></a><!-- doxytag: member="sf::Texture::RenderTarget" ref="aa5afc6f82b7b587ed5ada4d227ce32aa" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>RenderTarget</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">Image</a> living on the graphics card that can be used for drawing. </p>
<p><a class="el" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> stores pixels that can be drawn, with a sprite for example. A texture lives in the graphics card memory, therefore it is very fast to draw a texture to a render target, or copy a render target to a texture (the graphics card can access both directly).</p>
<p>Being stored in the graphics card memory has some drawbacks. A texture cannot be manipulated as freely as a <a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">sf::Image</a>, you need to prepare the pixels first and then upload them to the texture in a single operation (see <a class="el" href="classsf_1_1_texture.html#ae4eab5c6781316840b0c50ad08370963" title="Update the whole texture from an array of pixels.">Texture::update</a>).</p>
<p><a class="el" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> makes it easy to convert from/to <a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">sf::Image</a>, but keep in mind that these calls require transfers between the graphics card and the central memory, therefore they are slow operations.</p>
<p>A texture can be loaded from an image, but also directly from a file/memory/stream. The necessary shortcuts are defined so that you don't need an image first for the most common cases. However, if you want to perform some modifications on the pixels before creating the final texture, you can load your file to a <a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">sf::Image</a>, do whatever you need with the pixels, and then call <a class="el" href="classsf_1_1_texture.html#abec4567ad9856a3596dc74803f26fba2" title="Load the texture from an image.">Texture::loadFromImage</a>.</p>
<p>Since they live in the graphics card memory, the pixels of a texture cannot be accessed without a slow copy first. And they cannot be accessed individually. Therefore, if you need to read the texture's pixels (like for pixel-perfect collisions), it is recommended to store the collision information separately, for example in an array of booleans.</p>
<p>Like <a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">sf::Image</a>, <a class="el" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> can handle a unique internal representation of pixels, which is RGBA 32 bits. This means that a pixel must be composed of 8 bits red, green, blue and alpha channels -- just like a <a class="el" href="classsf_1_1_color.html" title="Utility class for manipulating RGBA colors.">sf::Color</a>.</p>
<p>Usage example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// This example shows the most common use of sf::Texture:</span>
 <span class="comment">// drawing a sprite</span>

 <span class="comment">// Load a texture from a file</span>
 <a class="code" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> texture;
 <span class="keywordflow">if</span> (!texture.<a class="code" href="classsf_1_1_texture.html#a8e1b56eabfe33e2e0e1cb03712c7fcc7" title="Load the texture from a file on disk.">loadFromFile</a>(<span class="stringliteral">&quot;texture.png&quot;</span>))
     <span class="keywordflow">return</span> -1;

 <span class="comment">// Assign it to a sprite</span>
 <a class="code" href="classsf_1_1_sprite.html" title="Drawable representation of a texture, with its own transformations, color, etc.">sf::Sprite</a> sprite;
 sprite.<a class="code" href="classsf_1_1_sprite.html#a3729c88d88ac38c19317c18e87242560" title="Change the source texture of the sprite.">setTexture</a>(texture);

 <span class="comment">// Draw the textured sprite</span>
 window.draw(sprite);
</pre></div><div class="fragment"><pre class="fragment"> <span class="comment">// This example shows another common use of sf::Texture:</span>
 <span class="comment">// streaming real-time data, like video frames</span>

 <span class="comment">// Create an empty texture</span>
 <a class="code" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> texture;
 <span class="keywordflow">if</span> (!texture.<a class="code" href="classsf_1_1_texture.html#a89b4c7d204acf1033c3a1b6e0a3ad0a3" title="Create the texture.">create</a>(640, 480))
     <span class="keywordflow">return</span> -1;

 <span class="comment">// Create a sprite that will display the texture</span>
 <a class="code" href="classsf_1_1_sprite.html" title="Drawable representation of a texture, with its own transformations, color, etc.">sf::Sprite</a> sprite(texture);

 <span class="keywordflow">while</span> (...) <span class="comment">// the main loop</span>
 {
     ...

     <span class="comment">// update the texture</span>
     sf::Uint8* pixels = ...; <span class="comment">// get a fresh chunk of pixels (the next frame of a movie, for example)</span>
     texture.<a class="code" href="classsf_1_1_texture.html#ae4eab5c6781316840b0c50ad08370963" title="Update the whole texture from an array of pixels.">update</a>(pixels);

     <span class="comment">// draw it</span>
     window.draw(sprite);

     ...
 }
</pre></div><p>Like <a class="el" href="classsf_1_1_shader.html" title="Shader class (vertex and fragment)">sf::Shader</a> that can be used as a raw OpenGL shader, <a class="el" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> can also be used directly as a raw texture for custom OpenGL geometry. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classsf_1_1_texture.html#ae9a4274e7b95ebf7244d09c7445833b0" title="Bind a texture for rendering.">sf::Texture::bind</a>(&amp;texture);
 ... render OpenGL geometry ...
 <a class="code" href="classsf_1_1_texture.html#ae9a4274e7b95ebf7244d09c7445833b0" title="Bind a texture for rendering.">sf::Texture::bind</a>(NULL);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_sprite.html" title="Drawable representation of a texture, with its own transformations, color, etc.">sf::Sprite</a>, <a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">sf::Image</a>, <a class="el" href="classsf_1_1_render_texture.html" title="Target for off-screen 2D rendering into a texture.">sf::RenderTexture</a> </dd></dl>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="aa6fd3bbe3c334b3c4428edfb2765a82e"></a><!-- doxytag: member="sf::Texture::CoordinateType" ref="aa6fd3bbe3c334b3c4428edfb2765a82e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classsf_1_1_texture.html#aa6fd3bbe3c334b3c4428edfb2765a82e">sf::Texture::CoordinateType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Types of texture coordinates that can be used for rendering. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa6fd3bbe3c334b3c4428edfb2765a82ea69d6228950882e4d68be4ba4dbe7df73"></a><!-- doxytag: member="Normalized" ref="aa6fd3bbe3c334b3c4428edfb2765a82ea69d6228950882e4d68be4ba4dbe7df73" args="" -->Normalized</em>&nbsp;</td><td>
<p><a class="el" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">Texture</a> coordinates in range [0 .. 1]. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fd3bbe3c334b3c4428edfb2765a82ea6372f9c3a10203a7a69d8d5da59d82ff"></a><!-- doxytag: member="Pixels" ref="aa6fd3bbe3c334b3c4428edfb2765a82ea6372f9c3a10203a7a69d8d5da59d82ff" args="" -->Pixels</em>&nbsp;</td><td>
<p><a class="el" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">Texture</a> coordinates in range [0 .. size]. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3e04674853b8533bf981db3173e3a4a7"></a><!-- doxytag: member="sf::Texture::Texture" ref="a3e04674853b8533bf981db3173e3a4a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1_texture.html#a3e04674853b8533bf981db3173e3a4a7">sf::Texture::Texture</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty texture. </p>

</div>
</div>
<a class="anchor" id="a524855cbf89de3b74be84d385fd229de"></a><!-- doxytag: member="sf::Texture::Texture" ref="a524855cbf89de3b74be84d385fd229de" args="(const Texture &amp;copy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1_texture.html#a3e04674853b8533bf981db3173e3a4a7">sf::Texture::Texture</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_texture.html">Texture</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>instance to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae9a4274e7b95ebf7244d09c7445833b0"></a><!-- doxytag: member="sf::Texture::bind" ref="ae9a4274e7b95ebf7244d09c7445833b0" args="(const Texture *texture, CoordinateType coordinateType=Normalized)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classsf_1_1_texture.html#ae9a4274e7b95ebf7244d09c7445833b0">sf::Texture::bind</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsf_1_1_texture.html#aa6fd3bbe3c334b3c4428edfb2765a82e">CoordinateType</a>&#160;</td>
          <td class="paramname"><em>coordinateType</em> = <code><a class="el" href="classsf_1_1_texture.html#aa6fd3bbe3c334b3c4428edfb2765a82ea69d6228950882e4d68be4ba4dbe7df73">Normalized</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind a texture for rendering. </p>
<p>This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix <a class="el" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> with OpenGL code.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> t1, t2;
 ...
 <a class="code" href="classsf_1_1_texture.html#ae9a4274e7b95ebf7244d09c7445833b0" title="Bind a texture for rendering.">sf::Texture::bind</a>(&amp;t1);
 <span class="comment">// draw OpenGL stuff that use t1...</span>
 <a class="code" href="classsf_1_1_texture.html#ae9a4274e7b95ebf7244d09c7445833b0" title="Bind a texture for rendering.">sf::Texture::bind</a>(&amp;t2);
 <span class="comment">// draw OpenGL stuff that use t2...</span>
 <a class="code" href="classsf_1_1_texture.html#ae9a4274e7b95ebf7244d09c7445833b0" title="Bind a texture for rendering.">sf::Texture::bind</a>(NULL);
 <span class="comment">// draw OpenGL stuff that use no texture...</span>
</pre></div><p>The <em>coordinateType</em> argument controls how texture coordinates will be interpreted. If Normalized (the default), they must be in range [0 .. 1], which is the default way of handling texture coordinates with OpenGL. If Pixels, they must be given in pixels (range [0 .. size]). This mode is used internally by the graphics classes of SFML, it makes the definition of texture coordinates more intuitive for the high-level API, users don't need to compute normalized values.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Pointer to the texture to bind, can be null to use no texture </td></tr>
    <tr><td class="paramname">coordinateType</td><td>Type of texture coordinates to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefc19bcd95565dd2348fd4cec0facddc"></a><!-- doxytag: member="sf::Texture::copyToImage" ref="aefc19bcd95565dd2348fd4cec0facddc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1_image.html">Image</a> <a class="el" href="classsf_1_1_texture.html#aefc19bcd95565dd2348fd4cec0facddc">sf::Texture::copyToImage</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the texture pixels to an image. </p>
<p>This function performs a slow operation that downloads the texture's pixels from the graphics card and copies them to a new image, potentially applying transformations to pixels if necessary (texture may be padded or flipped).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">Image</a> containing the texture's pixels</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_texture.html#abec4567ad9856a3596dc74803f26fba2" title="Load the texture from an image.">loadFromImage</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a89b4c7d204acf1033c3a1b6e0a3ad0a3"></a><!-- doxytag: member="sf::Texture::create" ref="a89b4c7d204acf1033c3a1b6e0a3ad0a3" args="(unsigned int width, unsigned int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_texture.html#a89b4c7d204acf1033c3a1b6e0a3ad0a3">sf::Texture::create</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create the texture. </p>
<p>If this function fails, the texture is left unchanged.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Width of the texture </td></tr>
    <tr><td class="paramname">height</td><td>Height of the texture</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if creation was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a0bf905d487b104b758549c2e9e20a3fb"></a><!-- doxytag: member="sf::Texture::getMaximumSize" ref="a0bf905d487b104b758549c2e9e20a3fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int <a class="el" href="classsf_1_1_texture.html#a0bf905d487b104b758549c2e9e20a3fb">sf::Texture::getMaximumSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum texture size allowed. </p>
<p>This maximum size is defined by the graphics driver. You can expect a value of 512 pixels for low-end graphics card, and up to 8192 pixels or more for newer hardware.</p>
<p>Note: The first call to this function, whether by your code or SFML will result in a context switch.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Maximum size allowed for textures, in pixels </dd></dl>

</div>
</div>
<a class="anchor" id="a0f370acd8f41c8b97a6959389c521c2c"></a><!-- doxytag: member="sf::Texture::getSize" ref="a0f370acd8f41c8b97a6959389c521c2c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1_vector2.html">Vector2u</a> <a class="el" href="classsf_1_1_texture.html#a0f370acd8f41c8b97a6959389c521c2c">sf::Texture::getSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the size of the texture. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size in pixels </dd></dl>

</div>
</div>
<a class="anchor" id="a007a19b48952b7854120bf423c102150"></a><!-- doxytag: member="sf::Texture::isRepeated" ref="a007a19b48952b7854120bf423c102150" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_texture.html#a007a19b48952b7854120bf423c102150">sf::Texture::isRepeated</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell whether the texture is repeated or not. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if repeat mode is enabled, false if it is disabled</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_texture.html#aaa87d1eff053b9d4d34a24c784a28658" title="Enable or disable repeating.">setRepeated</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1d6643d3c76f2be29dc401dc22749e16"></a><!-- doxytag: member="sf::Texture::isSmooth" ref="a1d6643d3c76f2be29dc401dc22749e16" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_texture.html#a1d6643d3c76f2be29dc401dc22749e16">sf::Texture::isSmooth</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell whether the smooth filter is enabled or not. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if smoothing is enabled, false if it is disabled</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_texture.html#a0c3bd6825b9a99714f10d44179d74324" title="Enable or disable the smooth filter.">setSmooth</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8e1b56eabfe33e2e0e1cb03712c7fcc7"></a><!-- doxytag: member="sf::Texture::loadFromFile" ref="a8e1b56eabfe33e2e0e1cb03712c7fcc7" args="(const std::string &amp;filename, const IntRect &amp;area=IntRect())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_texture.html#a8e1b56eabfe33e2e0e1cb03712c7fcc7">sf::Texture::loadFromFile</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_rect.html">IntRect</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em> = <code><a class="el" href="classsf_1_1_rect.html">IntRect</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load the texture from a file on disk. </p>
<p>This function is a shortcut for the following code: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">sf::Image</a> image;
 image.<a class="code" href="classsf_1_1_image.html#a9e4f2aa8e36d0cabde5ed5a4ef80290b" title="Load the image from a file on disk.">loadFromFile</a>(filename);
 texture.<a class="code" href="classsf_1_1_texture.html#abec4567ad9856a3596dc74803f26fba2" title="Load the texture from an image.">loadFromImage</a>(image, area);
</pre></div><p>The <em>area</em> argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the <em>area</em> rectangle crosses the bounds of the image, it is adjusted to fit the image size.</p>
<p>The maximum size for a texture depends on the graphics driver and can be retrieved with the getMaximumSize function.</p>
<p>If this function fails, the texture is left unchanged.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path of the image file to load </td></tr>
    <tr><td class="paramname">area</td><td>Area of the image to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if loading was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_texture.html#a2c4adb19dd4cbee0a588eeb85e52a249" title="Load the texture from a file in memory.">loadFromMemory</a>, <a class="el" href="classsf_1_1_texture.html#a6803a13465a7113a8964d1081841886d" title="Load the texture from a custom stream.">loadFromStream</a>, <a class="el" href="classsf_1_1_texture.html#abec4567ad9856a3596dc74803f26fba2" title="Load the texture from an image.">loadFromImage</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abec4567ad9856a3596dc74803f26fba2"></a><!-- doxytag: member="sf::Texture::loadFromImage" ref="abec4567ad9856a3596dc74803f26fba2" args="(const Image &amp;image, const IntRect &amp;area=IntRect())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_texture.html#abec4567ad9856a3596dc74803f26fba2">sf::Texture::loadFromImage</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_rect.html">IntRect</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em> = <code><a class="el" href="classsf_1_1_rect.html">IntRect</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load the texture from an image. </p>
<p>The <em>area</em> argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the <em>area</em> rectangle crosses the bounds of the image, it is adjusted to fit the image size.</p>
<p>The maximum size for a texture depends on the graphics driver and can be retrieved with the getMaximumSize function.</p>
<p>If this function fails, the texture is left unchanged.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td><a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">Image</a> to load into the texture </td></tr>
    <tr><td class="paramname">area</td><td>Area of the image to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if loading was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_texture.html#a8e1b56eabfe33e2e0e1cb03712c7fcc7" title="Load the texture from a file on disk.">loadFromFile</a>, <a class="el" href="classsf_1_1_texture.html#a2c4adb19dd4cbee0a588eeb85e52a249" title="Load the texture from a file in memory.">loadFromMemory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2c4adb19dd4cbee0a588eeb85e52a249"></a><!-- doxytag: member="sf::Texture::loadFromMemory" ref="a2c4adb19dd4cbee0a588eeb85e52a249" args="(const void *data, std::size_t size, const IntRect &amp;area=IntRect())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_texture.html#a2c4adb19dd4cbee0a588eeb85e52a249">sf::Texture::loadFromMemory</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_rect.html">IntRect</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em> = <code><a class="el" href="classsf_1_1_rect.html">IntRect</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load the texture from a file in memory. </p>
<p>This function is a shortcut for the following code: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">sf::Image</a> image;
 image.<a class="code" href="classsf_1_1_image.html#aaa6c7afa5851a51cec6ab438faa7354c" title="Load the image from a file in memory.">loadFromMemory</a>(data, size);
 texture.<a class="code" href="classsf_1_1_texture.html#abec4567ad9856a3596dc74803f26fba2" title="Load the texture from an image.">loadFromImage</a>(image, area);
</pre></div><p>The <em>area</em> argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the <em>area</em> rectangle crosses the bounds of the image, it is adjusted to fit the image size.</p>
<p>The maximum size for a texture depends on the graphics driver and can be retrieved with the getMaximumSize function.</p>
<p>If this function fails, the texture is left unchanged.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the file data in memory </td></tr>
    <tr><td class="paramname">size</td><td>Size of the data to load, in bytes </td></tr>
    <tr><td class="paramname">area</td><td>Area of the image to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if loading was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_texture.html#a8e1b56eabfe33e2e0e1cb03712c7fcc7" title="Load the texture from a file on disk.">loadFromFile</a>, <a class="el" href="classsf_1_1_texture.html#a6803a13465a7113a8964d1081841886d" title="Load the texture from a custom stream.">loadFromStream</a>, <a class="el" href="classsf_1_1_texture.html#abec4567ad9856a3596dc74803f26fba2" title="Load the texture from an image.">loadFromImage</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6803a13465a7113a8964d1081841886d"></a><!-- doxytag: member="sf::Texture::loadFromStream" ref="a6803a13465a7113a8964d1081841886d" args="(sf::InputStream &amp;stream, const IntRect &amp;area=IntRect())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_texture.html#a6803a13465a7113a8964d1081841886d">sf::Texture::loadFromStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1_input_stream.html">sf::InputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_rect.html">IntRect</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em> = <code><a class="el" href="classsf_1_1_rect.html">IntRect</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load the texture from a custom stream. </p>
<p>This function is a shortcut for the following code: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">sf::Image</a> image;
 image.<a class="code" href="classsf_1_1_image.html#a21122ded0e8368bb06ed3b9acfbfb501" title="Load the image from a custom stream.">loadFromStream</a>(stream);
 texture.<a class="code" href="classsf_1_1_texture.html#abec4567ad9856a3596dc74803f26fba2" title="Load the texture from an image.">loadFromImage</a>(image, area);
</pre></div><p>The <em>area</em> argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the <em>area</em> rectangle crosses the bounds of the image, it is adjusted to fit the image size.</p>
<p>The maximum size for a texture depends on the graphics driver and can be retrieved with the getMaximumSize function.</p>
<p>If this function fails, the texture is left unchanged.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Source stream to read from </td></tr>
    <tr><td class="paramname">area</td><td>Area of the image to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if loading was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_texture.html#a8e1b56eabfe33e2e0e1cb03712c7fcc7" title="Load the texture from a file on disk.">loadFromFile</a>, <a class="el" href="classsf_1_1_texture.html#a2c4adb19dd4cbee0a588eeb85e52a249" title="Load the texture from a file in memory.">loadFromMemory</a>, <a class="el" href="classsf_1_1_texture.html#abec4567ad9856a3596dc74803f26fba2" title="Load the texture from an image.">loadFromImage</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a80a089b6b19bb09b83012d5f0e6af9ba"></a><!-- doxytag: member="sf::Texture::operator=" ref="a80a089b6b19bb09b83012d5f0e6af9ba" args="(const Texture &amp;right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1_texture.html">Texture</a>&amp; sf::Texture::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_texture.html">Texture</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of assignment operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>Instance to assign</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="aaa87d1eff053b9d4d34a24c784a28658"></a><!-- doxytag: member="sf::Texture::setRepeated" ref="aaa87d1eff053b9d4d34a24c784a28658" args="(bool repeated)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_texture.html#aaa87d1eff053b9d4d34a24c784a28658">sf::Texture::setRepeated</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeated</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable repeating. </p>
<p>Repeating is involved when using texture coordinates outside the texture rectangle [0, 0, width, height]. In this case, if repeat mode is enabled, the whole texture will be repeated as many times as needed to reach the coordinate (for example, if the X texture coordinate is 3 * width, the texture will be repeated 3 times). If repeat mode is disabled, the "extra space" will instead be filled with border pixels. Warning: on very old graphics cards, white pixels may appear when the texture is repeated. With such cards, repeat mode can be used reliably only if the texture has power-of-two dimensions (such as 256x128). Repeating is disabled by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">repeated</td><td>True to repeat the texture, false to disable repeating</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_texture.html#a007a19b48952b7854120bf423c102150" title="Tell whether the texture is repeated or not.">isRepeated</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0c3bd6825b9a99714f10d44179d74324"></a><!-- doxytag: member="sf::Texture::setSmooth" ref="a0c3bd6825b9a99714f10d44179d74324" args="(bool smooth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_texture.html#a0c3bd6825b9a99714f10d44179d74324">sf::Texture::setSmooth</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smooth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable the smooth filter. </p>
<p>When the filter is activated, the texture appears smoother so that pixels are less noticeable. However if you want the texture to look exactly the same as its source file, you should leave it disabled. The smooth filter is disabled by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">smooth</td><td>True to enable smoothing, false to disable it</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_texture.html#a1d6643d3c76f2be29dc401dc22749e16" title="Tell whether the smooth filter is enabled or not.">isSmooth</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae4eab5c6781316840b0c50ad08370963"></a><!-- doxytag: member="sf::Texture::update" ref="ae4eab5c6781316840b0c50ad08370963" args="(const Uint8 *pixels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_texture.html#ae4eab5c6781316840b0c50ad08370963">sf::Texture::update</a> </td>
          <td>(</td>
          <td class="paramtype">const Uint8 *&#160;</td>
          <td class="paramname"><em>pixels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the whole texture from an array of pixels. </p>
<p>The <em>pixel</em> array is assumed to have the same size as the <em>area</em> rectangle, and to contain 32-bits RGBA pixels.</p>
<p>No additional check is performed on the size of the pixel array, passing invalid arguments will lead to an undefined behavior.</p>
<p>This function does nothing if <em>pixels</em> is null or if the texture was not previously created.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pixels</td><td>Array of pixels to copy to the texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1352d8e16c2aeb4df586ed65dd2c36b9"></a><!-- doxytag: member="sf::Texture::update" ref="a1352d8e16c2aeb4df586ed65dd2c36b9" args="(const Uint8 *pixels, unsigned int width, unsigned int height, unsigned int x, unsigned int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_texture.html#ae4eab5c6781316840b0c50ad08370963">sf::Texture::update</a> </td>
          <td>(</td>
          <td class="paramtype">const Uint8 *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update a part of the texture from an array of pixels. </p>
<p>The size of the <em>pixel</em> array must match the <em>width</em> and <em>height</em> arguments, and it must contain 32-bits RGBA pixels.</p>
<p>No additional check is performed on the size of the pixel array or the bounds of the area to update, passing invalid arguments will lead to an undefined behavior.</p>
<p>This function does nothing if <em>pixels</em> is null or if the texture was not previously created.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pixels</td><td>Array of pixels to copy to the texture </td></tr>
    <tr><td class="paramname">width</td><td>Width of the pixel region contained in <em>pixels</em> </td></tr>
    <tr><td class="paramname">height</td><td>Height of the pixel region contained in <em>pixels</em> </td></tr>
    <tr><td class="paramname">x</td><td>X offset in the texture where to copy the source pixels </td></tr>
    <tr><td class="paramname">y</td><td>Y offset in the texture where to copy the source pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a037cdf171af0fb392d07626a44a4ea17"></a><!-- doxytag: member="sf::Texture::update" ref="a037cdf171af0fb392d07626a44a4ea17" args="(const Image &amp;image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_texture.html#ae4eab5c6781316840b0c50ad08370963">sf::Texture::update</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the texture from an image. </p>
<p>Although the source image can be smaller than the texture, this function is usually used for updating the whole texture. The other overload, which has (x, y) additional arguments, is more convenient for updating a sub-area of the texture.</p>
<p>No additional check is performed on the size of the image, passing an image bigger than the texture will lead to an undefined behavior.</p>
<p>This function does nothing if the texture was not previously created.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td><a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">Image</a> to copy to the texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87f916490b757fe900798eedf3abf3ba"></a><!-- doxytag: member="sf::Texture::update" ref="a87f916490b757fe900798eedf3abf3ba" args="(const Image &amp;image, unsigned int x, unsigned int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_texture.html#ae4eab5c6781316840b0c50ad08370963">sf::Texture::update</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update a part of the texture from an image. </p>
<p>No additional check is performed on the size of the image, passing an invalid combination of image size and offset will lead to an undefined behavior.</p>
<p>This function does nothing if the texture was not previously created.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td><a class="el" href="classsf_1_1_image.html" title="Class for loading, manipulating and saving images.">Image</a> to copy to the texture </td></tr>
    <tr><td class="paramname">x</td><td>X offset in the texture where to copy the source image </td></tr>
    <tr><td class="paramname">y</td><td>Y offset in the texture where to copy the source image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3cceef238f7d5d2108a98dd38c17fc5"></a><!-- doxytag: member="sf::Texture::update" ref="ad3cceef238f7d5d2108a98dd38c17fc5" args="(const Window &amp;window)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_texture.html#ae4eab5c6781316840b0c50ad08370963">sf::Texture::update</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_window.html">Window</a> &amp;&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the texture from the contents of a window. </p>
<p>Although the source window can be smaller than the texture, this function is usually used for updating the whole texture. The other overload, which has (x, y) additional arguments, is more convenient for updating a sub-area of the texture.</p>
<p>No additional check is performed on the size of the window, passing a window bigger than the texture will lead to an undefined behavior.</p>
<p>This function does nothing if either the texture or the window was not previously created.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="classsf_1_1_window.html" title="Window that serves as a target for OpenGL rendering.">Window</a> to copy to the texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a154f246eb8059b602076009ab1cfd175"></a><!-- doxytag: member="sf::Texture::update" ref="a154f246eb8059b602076009ab1cfd175" args="(const Window &amp;window, unsigned int x, unsigned int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_texture.html#ae4eab5c6781316840b0c50ad08370963">sf::Texture::update</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1_window.html">Window</a> &amp;&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update a part of the texture from the contents of a window. </p>
<p>No additional check is performed on the size of the window, passing an invalid combination of window size and offset will lead to an undefined behavior.</p>
<p>This function does nothing if either the texture or the window was not previously created.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="classsf_1_1_window.html" title="Window that serves as a target for OpenGL rendering.">Window</a> to copy to the texture </td></tr>
    <tr><td class="paramname">x</td><td>X offset in the texture where to copy the source window </td></tr>
    <tr><td class="paramname">y</td><td>Y offset in the texture where to copy the source window </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/SFML/Graphics/<a class="el" href="_texture_8hpp_source.html">Texture.hpp</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>sf</b>      </li>
      <li class="navelem"><a class="el" href="classsf_1_1_texture.html">Texture</a>      </li>

    <li class="footer">Generated on Sat Mar 28 2015 16:45:58 for Metal Slug by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
