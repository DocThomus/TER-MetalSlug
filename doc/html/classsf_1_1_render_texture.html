<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Metal Slug: sf::RenderTexture Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Metal Slug
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Un clone de Metal Slug</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsf_1_1_render_texture.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">sf::RenderTexture Class Reference<div class="ingroups"><a class="el" href="group__graphics.html">Graphics module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="sf::RenderTexture" --><!-- doxytag: inherits="sf::RenderTarget" -->
<p>Target for off-screen 2D rendering into a texture.  
 <a href="classsf_1_1_render_texture.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_render_texture_8hpp_source.html">RenderTexture.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::RenderTexture:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsf_1_1_render_texture.png" usemap="#sf::RenderTexture_map" alt=""/>
  <map id="sf::RenderTexture_map" name="sf::RenderTexture_map">
<area href="classsf_1_1_render_target.html" title="Base class for all render targets (window, texture, ...)" alt="sf::RenderTarget" shape="rect" coords="0,56,111,80"/>
<area href="classsf_1_1_non_copyable.html" title="Utility class that makes any derived class non-copyable." alt="sf::NonCopyable" shape="rect" coords="0,0,111,24"/>
</map>
 </div></div>

<p><a href="classsf_1_1_render_texture-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#a19ee6e5b4c40ad251803389b3953a9c6">RenderTexture</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a19ee6e5b4c40ad251803389b3953a9c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94b84ab9335be84d2a014c964d973304"></a><!-- doxytag: member="sf::RenderTexture::~RenderTexture" ref="a94b84ab9335be84d2a014c964d973304" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#a94b84ab9335be84d2a014c964d973304">~RenderTexture</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#aefbb76eb3b87e368ab974b2660931ccb">create</a> (unsigned int width, unsigned int height, bool depthBuffer=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the render-texture.  <a href="#aefbb76eb3b87e368ab974b2660931ccb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#af08991e63c6020865dd07b20e27305b6">setSmooth</a> (bool smooth)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable texture smoothing.  <a href="#af08991e63c6020865dd07b20e27305b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#ae385f4f4dbd2af50fb11947bf0bcb83d">isSmooth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the smooth filtering is enabled or not.  <a href="#ae385f4f4dbd2af50fb11947bf0bcb83d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#af8f97b33512bf7d5b6be3da6f65f7365">setRepeated</a> (bool repeated)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable texture repeating.  <a href="#af8f97b33512bf7d5b6be3da6f65f7365"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#ae480a2ec7ee166afa50232e634d2668c">isRepeated</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the texture is repeated or not.  <a href="#ae480a2ec7ee166afa50232e634d2668c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#a5da95ecdbce615a80bb78399012508cf">setActive</a> (bool active=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate of deactivate the render-texture for rendering.  <a href="#a5da95ecdbce615a80bb78399012508cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#af92886d5faef3916caff9fa9ab32c555">display</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the contents of the target texture.  <a href="#af92886d5faef3916caff9fa9ab32c555"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsf_1_1_vector2.html">Vector2u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#a757ba45ec7a7deefcaef717049b00b8c">getSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the rendering region of the texture.  <a href="#a757ba45ec7a7deefcaef717049b00b8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1_texture.html">Texture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1_render_texture.html#a95bc5152c497066d31fdc57da8e17678">getTexture</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only reference to the target texture.  <a href="#a95bc5152c497066d31fdc57da8e17678"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Target for off-screen 2D rendering into a texture. </p>
<p><a class="el" href="classsf_1_1_render_texture.html" title="Target for off-screen 2D rendering into a texture.">sf::RenderTexture</a> is the little brother of <a class="el" href="classsf_1_1_render_window.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a>. It implements the same 2D drawing and OpenGL-related functions (see their base class <a class="el" href="classsf_1_1_render_target.html" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a> for more details), the difference is that the result is stored in an off-screen texture rather than being show in a window.</p>
<p>Rendering to a texture can be useful in a variety of situations: </p>
<ul>
<li>precomputing a complex static texture (like a level's background from multiple tiles) </li>
<li>applying post-effects to the whole scene with shaders </li>
<li>creating a sprite from a 3D object rendered with OpenGL </li>
<li>etc.</li>
</ul>
<p>Usage example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Create a new render-window</span>
 <a class="code" href="classsf_1_1_render_window.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a> window(<a class="code" href="classsf_1_1_video_mode.html" title="VideoMode defines a video mode (width, height, bpp)">sf::VideoMode</a>(800, 600), <span class="stringliteral">&quot;SFML window&quot;</span>);

 <span class="comment">// Create a new render-texture</span>
 <a class="code" href="classsf_1_1_render_texture.html" title="Target for off-screen 2D rendering into a texture.">sf::RenderTexture</a> texture;
 <span class="keywordflow">if</span> (!texture.<a class="code" href="classsf_1_1_render_texture.html#aefbb76eb3b87e368ab974b2660931ccb" title="Create the render-texture.">create</a>(500, 500))
     <span class="keywordflow">return</span> -1;

 <span class="comment">// The main loop</span>
 <span class="keywordflow">while</span> (window.isOpen())
 {
    <span class="comment">// Event processing</span>
    <span class="comment">// ...</span>

    <span class="comment">// Clear the whole texture with red color</span>
    texture.<a class="code" href="classsf_1_1_render_target.html#a6bb6f0ba348f2b1e2f46114aeaf60f26" title="Clear the entire target with a single color.">clear</a>(<a class="code" href="classsf_1_1_color.html#a127dbf55db9c07d0fa8f4bfcbb97594a" title="Red predefined color.">sf::Color::Red</a>);

    <span class="comment">// Draw stuff to the texture</span>
    texture.<a class="code" href="classsf_1_1_render_target.html#a12417a3bcc245c41d957b29583556f39" title="Draw a drawable object to the render target.">draw</a>(sprite);  <span class="comment">// sprite is a sf::Sprite</span>
    texture.<a class="code" href="classsf_1_1_render_target.html#a12417a3bcc245c41d957b29583556f39" title="Draw a drawable object to the render target.">draw</a>(shape);   <span class="comment">// shape is a sf::Shape</span>
    texture.<a class="code" href="classsf_1_1_render_target.html#a12417a3bcc245c41d957b29583556f39" title="Draw a drawable object to the render target.">draw</a>(text);    <span class="comment">// text is a sf::Text</span>

    <span class="comment">// We&#39;re done drawing to the texture</span>
    texture.<a class="code" href="classsf_1_1_render_texture.html#af92886d5faef3916caff9fa9ab32c555" title="Update the contents of the target texture.">display</a>();

    <span class="comment">// Now we start rendering to the window, clear it first</span>
    window.clear();

    <span class="comment">// Draw the texture</span>
    <a class="code" href="classsf_1_1_sprite.html" title="Drawable representation of a texture, with its own transformations, color, etc.">sf::Sprite</a> sprite(texture.<a class="code" href="classsf_1_1_render_texture.html#a95bc5152c497066d31fdc57da8e17678" title="Get a read-only reference to the target texture.">getTexture</a>());
    window.draw(sprite);

    <span class="comment">// End the current frame and display its contents on screen</span>
    window.display();
 }
</pre></div><p>Like <a class="el" href="classsf_1_1_render_window.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a>, <a class="el" href="classsf_1_1_render_texture.html" title="Target for off-screen 2D rendering into a texture.">sf::RenderTexture</a> is still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands. If you need a depth buffer for 3D rendering, don't forget to request it when calling <a class="el" href="classsf_1_1_render_texture.html#aefbb76eb3b87e368ab974b2660931ccb" title="Create the render-texture.">RenderTexture::create</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_render_target.html" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a>, <a class="el" href="classsf_1_1_render_window.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a>, <a class="el" href="classsf_1_1_view.html" title="2D camera that defines what region is shown on screen">sf::View</a>, <a class="el" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a19ee6e5b4c40ad251803389b3953a9c6"></a><!-- doxytag: member="sf::RenderTexture::RenderTexture" ref="a19ee6e5b4c40ad251803389b3953a9c6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1_render_texture.html#a19ee6e5b4c40ad251803389b3953a9c6">sf::RenderTexture::RenderTexture</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty, invalid render-texture. You must call create to have a valid render-texture.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_render_texture.html#aefbb76eb3b87e368ab974b2660931ccb" title="Create the render-texture.">create</a> </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aefbb76eb3b87e368ab974b2660931ccb"></a><!-- doxytag: member="sf::RenderTexture::create" ref="aefbb76eb3b87e368ab974b2660931ccb" args="(unsigned int width, unsigned int height, bool depthBuffer=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_render_texture.html#aefbb76eb3b87e368ab974b2660931ccb">sf::RenderTexture::create</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>depthBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create the render-texture. </p>
<p>Before calling this function, the render-texture is in an invalid state, thus it is mandatory to call it before doing anything with the render-texture. The last parameter, <em>depthBuffer</em>, is useful if you want to use the render-texture for 3D OpenGL rendering that requires a depth buffer. Otherwise it is unnecessary, and you should leave this parameter to false (which is its default value).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Width of the render-texture </td></tr>
    <tr><td class="paramname">height</td><td>Height of the render-texture </td></tr>
    <tr><td class="paramname">depthBuffer</td><td>Do you want this render-texture to have a depth buffer?</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if creation has been successful </dd></dl>

</div>
</div>
<a class="anchor" id="af92886d5faef3916caff9fa9ab32c555"></a><!-- doxytag: member="sf::RenderTexture::display" ref="af92886d5faef3916caff9fa9ab32c555" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_render_texture.html#af92886d5faef3916caff9fa9ab32c555">sf::RenderTexture::display</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the contents of the target texture. </p>
<p>This function updates the target texture with what has been drawn so far. Like for windows, calling this function is mandatory at the end of rendering. Not calling it may leave the texture in an undefined state. </p>

</div>
</div>
<a class="anchor" id="a757ba45ec7a7deefcaef717049b00b8c"></a><!-- doxytag: member="sf::RenderTexture::getSize" ref="a757ba45ec7a7deefcaef717049b00b8c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsf_1_1_vector2.html">Vector2u</a> <a class="el" href="classsf_1_1_render_texture.html#a757ba45ec7a7deefcaef717049b00b8c">sf::RenderTexture::getSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the size of the rendering region of the texture. </p>
<p>The returned value is the size that you passed to the create function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size in pixels </dd></dl>

<p>Implements <a class="el" href="classsf_1_1_render_target.html#a2e5ade2457d9fb4c4907ae5b3d9e94a5">sf::RenderTarget</a>.</p>

</div>
</div>
<a class="anchor" id="a95bc5152c497066d31fdc57da8e17678"></a><!-- doxytag: member="sf::RenderTexture::getTexture" ref="a95bc5152c497066d31fdc57da8e17678" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1_texture.html">Texture</a>&amp; <a class="el" href="classsf_1_1_render_texture.html#a95bc5152c497066d31fdc57da8e17678">sf::RenderTexture::getTexture</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a read-only reference to the target texture. </p>
<p>After drawing to the render-texture and calling Display, you can retrieve the updated texture using this function, and draw it using a sprite (for example). The internal <a class="el" href="classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> of a render-texture is always the same instance, so that it is possible to call this function once and keep a reference to the texture even after it is modified.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Const reference to the texture </dd></dl>

</div>
</div>
<a class="anchor" id="ae480a2ec7ee166afa50232e634d2668c"></a><!-- doxytag: member="sf::RenderTexture::isRepeated" ref="ae480a2ec7ee166afa50232e634d2668c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_render_texture.html#ae480a2ec7ee166afa50232e634d2668c">sf::RenderTexture::isRepeated</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell whether the texture is repeated or not. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if texture is repeated</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_render_texture.html#af8f97b33512bf7d5b6be3da6f65f7365" title="Enable or disable texture repeating.">setRepeated</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae385f4f4dbd2af50fb11947bf0bcb83d"></a><!-- doxytag: member="sf::RenderTexture::isSmooth" ref="ae385f4f4dbd2af50fb11947bf0bcb83d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_render_texture.html#ae385f4f4dbd2af50fb11947bf0bcb83d">sf::RenderTexture::isSmooth</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell whether the smooth filtering is enabled or not. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if texture smoothing is enabled</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_render_texture.html#af08991e63c6020865dd07b20e27305b6" title="Enable or disable texture smoothing.">setSmooth</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5da95ecdbce615a80bb78399012508cf"></a><!-- doxytag: member="sf::RenderTexture::setActive" ref="a5da95ecdbce615a80bb78399012508cf" args="(bool active=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1_render_texture.html#a5da95ecdbce615a80bb78399012508cf">sf::RenderTexture::setActive</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activate of deactivate the render-texture for rendering. </p>
<p>This function makes the render-texture's context current for future OpenGL rendering operations (so you shouldn't care about it if you're not doing direct OpenGL stuff). Only one context can be current in a thread, so if you want to draw OpenGL geometry to another render target (like a <a class="el" href="classsf_1_1_render_window.html" title="Window that can serve as a target for 2D drawing.">RenderWindow</a>) don't forget to activate it again.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>True to activate, false to deactivate</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if operation was successful, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af8f97b33512bf7d5b6be3da6f65f7365"></a><!-- doxytag: member="sf::RenderTexture::setRepeated" ref="af8f97b33512bf7d5b6be3da6f65f7365" args="(bool repeated)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_render_texture.html#af8f97b33512bf7d5b6be3da6f65f7365">sf::RenderTexture::setRepeated</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeated</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable texture repeating. </p>
<p>This function is similar to <a class="el" href="classsf_1_1_texture.html#aaa87d1eff053b9d4d34a24c784a28658" title="Enable or disable repeating.">Texture::setRepeated</a>. This parameter is disabled by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">repeated</td><td>True to enable repeating, false to disable it</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_render_texture.html#ae480a2ec7ee166afa50232e634d2668c" title="Tell whether the texture is repeated or not.">isRepeated</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af08991e63c6020865dd07b20e27305b6"></a><!-- doxytag: member="sf::RenderTexture::setSmooth" ref="af08991e63c6020865dd07b20e27305b6" args="(bool smooth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1_render_texture.html#af08991e63c6020865dd07b20e27305b6">sf::RenderTexture::setSmooth</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smooth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable texture smoothing. </p>
<p>This function is similar to <a class="el" href="classsf_1_1_texture.html#a0c3bd6825b9a99714f10d44179d74324" title="Enable or disable the smooth filter.">Texture::setSmooth</a>. This parameter is disabled by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">smooth</td><td>True to enable smoothing, false to disable it</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1_render_texture.html#ae385f4f4dbd2af50fb11947bf0bcb83d" title="Tell whether the smooth filtering is enabled or not.">isSmooth</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/SFML/Graphics/<a class="el" href="_render_texture_8hpp_source.html">RenderTexture.hpp</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>sf</b>      </li>
      <li class="navelem"><a class="el" href="classsf_1_1_render_texture.html">RenderTexture</a>      </li>

    <li class="footer">Generated on Sat Mar 28 2015 16:45:58 for Metal Slug by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
